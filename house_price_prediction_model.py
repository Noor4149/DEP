# -*- coding: utf-8 -*-
"""House price prediction model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cr63WHIKN9SpQPb7k30hEQVfL66dr6a9
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

mydata = pd.read_csv('/content/Housing.csv')

mydata.head(10)

mydata.shape

mydata.info()

mydata.columns

mydata.describe(include ='all')

mydata.isnull().sum()

plt.hist(mydata['price'])
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

sns.boxplot(x ='furnishingstatus', y ='price', data = mydata)
plt.xlabel('Furnishing Status')
plt.ylabel('Price')
plt.show()

plt.scatter( mydata['area'], mydata['price'])
plt.xlabel('Area')
plt.ylabel('Price')
plt.show()

plt.hist( mydata['area'], bins=10 )
plt.xlabel('Area')
plt.ylabel('Frequency')
plt.show()

sns.kdeplot( mydata['price'], shade = True )
plt.xlabel('Price')
plt.ylabel('Density')
plt.show()

binary_val = ['mainroad', 'guestroom',	'basement',	'hotwaterheating',	'airconditioning',	'prefarea']

mydata[binary_val]

def binary_map(x):
  """ function will map the values of 'yes' and 'no' into '1' and '0' respectively. """
  return x.map({ 'yes' : 1 , 'no' : 0})

mydata[binary_val] = mydata[binary_val].apply(binary_map)

mydata[binary_val]

mydata.head(5)

mydata.tail(5)

dummy = pd.get_dummies(mydata['furnishingstatus'], dtype = int)

dummy.head(5)

dummy = pd.get_dummies(mydata['furnishingstatus'], drop_first= True, dtype = int)
dummy.head(5)

mydata = pd.concat([mydata, dummy], axis=1)

mydata.head()

mydata.drop(['furnishingstatus'], axis = 1, inplace = True)

mydata.head()

mydata.columns

from sklearn.model_selection import train_test_split

np.random.seed(0)

train, test = train_test_split(mydata, train_size = 0.7 , test_size = 0.3, random_state = 100)

train.head(5)

test.head(5)

train.shape

test.shape

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

col_var = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking', 'price']

train[col_var] = scaler.fit_transform(train[col_var])

modeltrain_y = train.pop('price')
modeltrain_x = train

from sklearn.linear_model import LinearRegression

reg = LinearRegression()

reg.fit(modeltrain_x, modeltrain_y)

coefficients = reg.coef_
print(coefficients)

score = reg.score(modeltrain_x, modeltrain_y)
print(score*100)

col_var = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking', 'price']

test[col_var] = scaler.fit_transform(test[col_var])

modeltest_y = test.pop('price')
modeltest_x = test

priceprediction = reg.predict(modeltest_x)

from sklearn.metrics import r2_score

RR = r2_score(modeltest_y, priceprediction)
print(RR*100)

modeltest_y.shape

mat_y_test = modeltest_y.values.reshape(-1, 1)

df = pd.DataFrame({'actual': mat_y_test.flatten(), 'predicted': priceprediction.flatten()})

df.head()*100000

comp = plt.figure()
plt.scatter(modeltest_y, priceprediction)

plt.title('Actual vs Prediction')
plt.xlabel('Actual', fontsize = 17)
plt.ylabel('Predicted', fontsize = 17)